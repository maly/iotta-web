---
id: 369
title: Hereze
date: 2017-10-08T17:35:21+00:00
author: Martin Maly
layout: post
guid: https://iotta.cz/?p=369
permalink: /hereze/
image: http://iotta.cz/wp-content/uploads/sites/17/2017/03/arduino-uno.jpg
categories:
  - Arduino
  - Arduino
---
M치m r치d exotick칠 programovac칤 jazyky i Arduino a 콏칤k치m si: fakt jsme pro osmibity nevymysleli nic lep코칤ho a pohodln캩j코칤ho ne je C? M치m tendenci nev캩콏it lidem, co si mysl칤, 쬰 to dokonal칠 u vzniklo kdysi a v코echno nov캩j코칤 je nanic&#8230;_N치sleduj칤 zmaten칠 칰vahy a kac칤콏sk칠 my코lenky, kter칠 si tak poznamen치v치m, a asi by je nikdo nem캩l 캜칤st._

<!--more-->

Jasn캩, takov칳 [Forth pro Arduino](https://playground.arduino.cc/CommonTopics/ForthOnArduino), to je sice kuriozn칤 v캩c, ale mohla by fungovat. Teda kdyby lidi um캩li je코t캩 dneska Forth. Jinak to je_sui generis_ st치le rychl칳 n치stroj se zaj칤mav칳mi vlastnostmi. Zl칤 jazykov칠 sice tvrd칤, 쬰 to je assembler, jen m칤켿 pochopiteln칳, autor Forthu je velk칳 podiv칤n (nebo_radik치ln칤_, jak to vezmete), ale zaj칤mav칳 jazyk to rozhodn캩 je, pro osmibity je docela vhodn칳 a kdy v칤te jak na to, je to i siln칳 vyjad콏ovac칤 prost콏edek.

Ob캜as p콏em칳코l칤m nad Arduinem z tohoto 칰hlu pohledu. M치me tu harvardskou architekturu jedno캜ipu, m치lo RAMky, osmibitov칳 procesor &#8211; a c칠캜ko. Nebo assembler. Po콏치d stejn칠, s prominut칤m, paradigma. Ne코lo by pou쮂셦 n캩co specifi캜t캩j코칤ho? N캩co, co by m캩lo siln캩j코칤 vyjad콏ovac칤 schopnosti ne c칠캜ko, ale bylo to z치rove켿 nen치ro캜n칠, aby se to ve코lo do osmibitu?

N캩kdy, kdy m치m 캜as a n치ladu, tak p콏em칳코l칤m nad &#8222;alternativn칤mi v칳vojov칳mi jazyky&#8220; pro Arduino. Jako takov칠 ment치ln칤 cvi캜en칤, rozum칤te? Te캞 v p치tek m캩 napadlo ud캩lat jednu v캩c, nad kterou jsem u p콏ed 캜asem p콏em칳코lel: ned칤vat se na Arduino jako na init() a loop(), ale jako na soubor mnoha soub캩쬹캩 funguj칤c칤ch programov칳ch modul콢, kter칠 spolu komunikuj칤. Tak쬰 nap콏칤klad rozsv칤cen칤 LEDky na stisk tla캜칤tka by neprob칤halo stylem &#8222;if tla캜칤tko then ledka&#8220; v nekone캜n칠 smy캜ce, ale pomoc칤 dvou deklarovan칳ch proces콢. Jeden hl칤d치 tla캜칤tko a jeho stav n캩kam ukl치d치, druh칳 rozsv캩c칤 LEDku podle instrukc칤, co m치. Blika캜 by byly taky dva procesy, jen m칤sto toho s tla캜칤tkem by tam byl proces s 캜asova캜em&#8230; Jo, tro코ku, ale fakt jen tro코i캜ku jsem se inspiroval Erlangem.

Jasn캩, 쬰 n캩kde pod t칤mhle v코칤m by le쬰l zase jen ten oby캜ejn칳 assembler, nebo to c칠캜ko, nekone캜n치 smy캜ka, a tohle v코echno je jen_syntaktick칳 cukr_, ale to asi nen칤 ten hlavn칤 probl칠m. _V쬯y콘 do d콢sledku vzato cokoli nad strojov칳 k칩d je cukr, v캜etn캩 hexadecim치ln칤ho vyj치d콏en칤 opera캜n칤ch k칩d콢. 游땔_

No a jak si tak ob캜as s touhle my코lenkou pohr치v치m, tak si 콏칤k치m, k 캜emu by to vedlo. V칳voj치콏 by musel programovat jinak. Jako 쬰 fakt_jinak_. Hodn캩 to p콏ipom칤n치 posun od klasick칠ho imperativn칤ho C칠캜ka t콏eba n캩kam k VHDL, kde taky nen칤 쮂멳n칠 &#8222;nejd콏칤v, pak, potom, potom, potom ve smy캜ce toto, pak pokud toto, tak tamto, a nakonec toto&#8220;. Jen spousta blok콢, kter칠 pracuj칤 najednou. N캩co podobn칠ho, ale v men코칤m, za쬴jete p콏i prvn칤 sr치쬮e s asynchronn칤m programov치n칤m: nikdo v치m nezaru캜칤, 쬰 se toto stane a po tamtom.

Na druhou stranu: nen칤 snad Arduino pln칠 asynchronn칤ch ud치lost칤, kter칠 je t콏eba obslou쬴t? Implementace JavaScriptu by byla (asi, je코t캩 jsem to neprom칳코lel) n치ro캜n치, ale n캩co ve stylu &#8222;ud치lost &#8211; obsluha&#8220; by se mo쬹치 hodilo&#8230;

A tak m캩 zrovna te캞 o v칤kendu napadlo ud캩lat takov칳 miniengine. V칳sledkem je spousta omezen칤 program치torsk칠ho rozletu a kooperativn칤 multithreading (proto ta omezen칤).

P콏edstavte si syst칠m, kde m콢쬰 b캩쬰t n캩kolik vl치ken nar치z. Proto쬰 jde o kooperativn칤 multithreading, nikoli preemptivn칤, je pot콏eba trocha sebekontroly. Proto jsem si program rozd캩lil do miniaturn칤ch subproces콢. Ka쬯칳 subproces b캩쮂 v jednom vl치kn캩 a plat칤 pro n캩j n캩kolik z치kladn칤ch v캩c칤:

  * Subproces odpov칤d치 c칠캜kov칠 funkci_void(){&#8230;}_
  * Subproces je bu캞 opakov치n v dan칠m vl치kn캩 st치le dokola (loop), nebo je proveden jen jednou (a pak je vl치kno uvoln캩no &#8211; one shoot), nebo m콢쬰 콏칤ct, kter칳 subproces m치 b칳t spu코t캩n칳 po n캩m (chain).
  * Pokud subproces ur캜칤 sv칠ho n치sledovn칤ka (kter칳m m콢쬰 b칳t i on s치m), m콢쬰 콏칤ct, za jak dlouho m치 b칳t n치sledovn칤k spu코t캩n (delayed).
  * D콢vodem je to, 쬰 subproces m치 zak치z치no volat delay()&#8230;
  * U kooperativn칤ho multithreadingu by v콢bec nikdo nem캩l zdr쬺vat. M캩l by ud캩lat to, co mus칤, a skon캜it. A proto쬰 jsem trochu radik치ln칤, tak bych mo쬹치 zak치zal i smy캜ky (ostatn캩 jsou jazyky, co se bez nich obejdou). Fakt. Smy캜ku jako takovou lze nasimulovat pomoc칤 subprocesu, kter칳 b캩쮂 st치le dokola, a p콏i dosa쬰n칤 n캩jak칠 podm칤nky bu캞 skon캜칤, nebo p콏ed치 콏칤zen칤 jinam.
  * Pokud m치te tendenci t콏eba 캜ekat na stisknut칤 tla캜칤tka ve smy캜ce while(), tak to tady nep콢jde. M칤sto toho je na m칤st캩 ud캩lat subproces, kter칳 n캩kam ozn치m칤, 쬰 tla캜칤tko bylo stisknuto.
  * Subproces m콢쬰 zavolat dal코칤 subproces v nov칠m vl치kn캩. Ov코em ne캜ek치 na jeho dob캩hnut칤, ani na v칳sledek, prost캩 s치m b캩쮂 d치l, nez치visle na ostatn칤ch vl치knech.
  * Kdy subproces skon캜칤 (one shoot), vl치kno je uvoln캩no.
  * Subproces m치 lok치ln칤 prom캩nn칠. Jakmile dob캩hne, uvoln칤 je.
  * S okol칤m komunikuje subproces t칤m, 쬰 m캩n칤 hodnoty prom캩nn칳ch prost콏ed칤 a spou코t칤 dal코칤 subprocesy._Tady zva쬿ju, jestli toto n캩jak neomezit a nezvolit t콏eba model pos칤l치n칤 zpr치v mezi procesy, ale se v코emi t캩mi semafory a frontami mi to p콏ipad치 na osmibit s 2kB RAM hodn캩 n치kladn칠&#8230; Je코t캩 promysl칤m._
  * M치me dv캩 kila RAMky, tak쬰 asi n캩jak칠 velk칠 hran칤 si na ochranu pam캩ti a izolaci proces콢 nep콏ipad치 v 칰vahu, o spr치v캩 zdroj콢 nemluv캩. Ale asi by 코lo ud캩lat n캩co na zp콢sob &#8222;prost콏ed칤&#8220;&#8230;
  * Nic v치m nebr치n칤 spustit si subproces, kter칳 p콏istupuje k jednomu HW zdroji, t콏eba ve t콏ech kopi칤ch, ale dopadne to 코patn캩. Lep코칤 je postupovat stylem &#8222;ka쬯칳 HW m치 obslu쬹칳 subproces&#8220;.
  * _P콏em칳코l칤m, jestli je 칰캜eln칠 povolit usp치n칤 vl치kna a jeho probuzen칤 jin칳m vl치knem&#8230;_

V칳hoda toho v코eho je, 쬰 subprocesy jsou mali캜k칠, p콏ehledn칠, s jasn캩 dan칳m koncem (nen칤 nic jako &#8222;캜ek치n칤&#8220; nebo &#8222;nekone캜n치 smy캜ka&#8220;). Nev칳hoda je, 쬰 kone캜nost subproces콢 z치vis칤 jen na tom, jestli program치tor dobrovoln캩 dodr쮂 pravidla, kter치 ho omez칤. T콏eba nebude pou쮂셨at delay(), ale odpo캜칤t치 si pot콏ebn칳 캜as z hodnoty 캜asova캜e&#8230;

Na druhou stranu, kdy se toto vhodn캩 zakapotuje a dostate캜n캩 oslad칤 n캩jak칳mi hezk칳mi featurami, tak by to mohl b칳t zaj칤mav칳 n치stroj pro ur캜it칠 kategorie aplikac칤. Je코t캩 nad t칤m budu p콏em칳코let.